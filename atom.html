<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Átomo — unatomo</title>
  <style>
    :root{ --bg:#0b1020; --text:#e5e7eb; --muted:#94a3b8; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,Segoe UI,Inter,Roboto,Arial}
    #app{position:fixed;inset:0}
    canvas{display:block;width:100%;height:100%}
    .tip{position:fixed;right:14px;top:14px;z-index:10;font-size:12.5px;color:var(--muted);background:rgba(17,24,39,.55);border:1px solid #223052;padding:8px 10px;border-radius:12px}
    .hud{position:fixed;left:16px;bottom:16px;z-index:10;display:flex;gap:8px;align-items:center;background:rgba(17,24,39,.6);backdrop-filter:blur(8px);border:1px solid #223052;padding:8px 10px;border-radius:12px}
    .hud a{color:var(--muted);text-decoration:none;font-size:12px}
    .hud a:hover{text-decoration:underline}
    .fab{position:fixed;right:16px;bottom:16px;z-index:11;border:1px solid #223052;background:#18223a;color:var(--text);border-radius:999px;padding:10px 12px;font-weight:600;cursor:pointer}
    .fab:hover{filter:brightness(1.06);transform:translateY(-1px)}
    .nowebgl{position:fixed;inset:0;display:grid;place-items:center;padding:24px;text-align:center}
    .nowebgl .card{max-width:680px;background:linear-gradient(180deg,#0a0f20,#0b1224);border:1px solid #263247;border-radius:16px;padding:18px}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="tip">Arrastra para <b>girar</b>, rueda para <b>acercar</b>. Pulsa <b>R</b> para recentrar.</div>
  <button class="fab" id="resetBtn" title="Recentrar (R)">Recentrar</button>
  <div class="hud">
    <a href="./">← volver</a>
    <span style="opacity:.45">·</span>
    <a href="#" id="exportPNG">capturar PNG</a>
  </div>

  <!-- Carga clásica (sin módulos) -->
  <script>
    // Si WebGL no está disponible, mostramos un aviso y paramos
    try{ const _t = document.createElement('canvas').getContext('webgl'); if(!_t) throw 0; }catch(e){
      const div = document.createElement('div');
      div.className = 'nowebgl';
      div.innerHTML = '<div class="card"><h1>Tu navegador no soporta WebGL</h1><p>Prueba con una versión más reciente de Chrome, Edge, Firefox o Safari.</p></div>';
      document.body.appendChild(div);
      throw new Error('WebGL not available');
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
  
  <script>
    // === Escena básica ===
    const root = document.getElementById('app') || document.body; // fallback si falta #app
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--bg').trim()||'#0b1020');

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(8, 6, 10);

    // Controles propios (drag para rotar, rueda para zoom)
    let isDown=false, lastX=0,lastY=0; let rotY=0, rotX=0; let distance=14;
    const target = new THREE.Vector3(0,0,0);
    function updateCamera(){
      const phi = THREE.MathUtils.degToRad(30+rotX);
      const theta = THREE.MathUtils.degToRad(40+rotY);
      camera.position.set(
        target.x + distance*Math.sin(phi)*Math.cos(theta),
        target.y + distance*Math.cos(phi),
        target.z + distance*Math.sin(phi)*Math.sin(theta)
      );
      camera.lookAt(target);
    }
    updateCamera();
    renderer.domElement.addEventListener('mousedown', (e)=>{ isDown=true; lastX=e.clientX; lastY=e.clientY; });
    addEventListener('mouseup', ()=>{ isDown=false; });
    addEventListener('mousemove', (e)=>{
      if(!isDown) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
      rotY += dx*0.25; rotX += dy*0.25; rotX=Math.max(-85, Math.min(85, rotX));
      updateCamera();
    });
    renderer.domElement.addEventListener('wheel',(e)=>{ e.preventDefault(); distance *= (1 + Math.sign(e.deltaY)*0.08); distance=Math.max(4, Math.min(40, distance)); updateCamera(); }, {passive:false});
    controls.enableDamping = true;
    controls.dampingFactor = .08;
    controls.target.set(0,0,0);

    // Luces
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,7,3); scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, 0.25));

    // Núcleo
    const nucleus = new THREE.Mesh(
      new THREE.IcosahedronGeometry(1.4, 3),
      new THREE.MeshStandardMaterial({ color: 0x8893ff, metalness: 0.25, roughness: 0.35, emissive: 0x1a1f5a, emissiveIntensity: 0.35, transparent: true, opacity: 0.9 })
    );
    scene.add(nucleus);
    const nucleusGlow = new THREE.PointLight(0x7dd3fc, 0.36, 30); scene.add(nucleusGlow);

    // Grupo del átomo
    const group = new THREE.Group(); scene.add(group);

    // Materiales
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x8b5cf6, transparent:true, opacity:0.35, wireframe:true });
    const electronMat = new THREE.MeshStandardMaterial({ color: 0x22d3ee, emissive:0x0ea5e9, emissiveIntensity:.7, roughness:.2, metalness:.1 });

    const rings = []; const electrons = [];

    function makeRing(radius){
      const g = new THREE.TorusGeometry(radius, 0.015*radius, 12, 180);
      const m = new THREE.Mesh(g, ringMat.clone());
      m.rotation.x = Math.random()*Math.PI;
      m.rotation.y = Math.random()*Math.PI;
      group.add(m);
      rings.push({ mesh: m, radius });
    }
    function makeElectron(ringIndex){
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.12, 24, 24), electronMat.clone());
      const angle = Math.random()*Math.PI*2;
      const speed = (Math.random()*0.6+0.4) * 0.6; // rad/s base
      electrons.push({ mesh: sphere, ringIndex, angle, speed });
      group.add(sphere);
    }

    // Construcción fija (sin GUI por ahora)
    const ringsCount = 3; const electronsPerRing = [2,8,8]; const ringGap = 1.2;
    (function build(){
      const base = 2.3;
      for(let i=0;i<ringsCount;i++){
        const radius = base + i*ringGap;
        makeRing(radius);
        const count = electronsPerRing[i] || 0;
        for(let j=0;j<count;j++) makeElectron(i);
      }
    })();

    // Animación
    const clock = new THREE.Clock();
    function update(dt){
      nucleus.rotation.y += dt*0.15;
      nucleus.rotation.x += dt*0.08;
      nucleusGlow.intensity = 0.3 + 0.1*Math.sin(performance.now()*0.0015);
      group.rotation.y += dt*0.25;
      rings.forEach((r,i)=>{
        const t = performance.now()*0.0004 + i*0.7;
        r.mesh.rotation.x += (Math.sin(t)*0.12 - r.mesh.rotation.x) * 0.02;
        r.mesh.rotation.z += (Math.cos(t*1.2)*0.12 - r.mesh.rotation.z) * 0.02;
      });
      electrons.forEach((e)=>{
        const ring = rings[e.ringIndex]; if(!ring) return;
        const radius = ring.radius; e.angle += e.speed * dt;
        const m = ring.mesh.matrixWorld;
        const x = Math.cos(e.angle)*radius; const y = 0; const z = Math.sin(e.angle)*radius;
        const p = new THREE.Vector3(x,y,z).applyMatrix4(m);
        e.mesh.position.copy(p);
      });
    }
    function render(){
      const dt = clock.getDelta();
      
      update(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    render();

    // Resize + reset + export
    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
    function resetView(){ rotX=0; rotY=0; distance=14; updateCamera(); }
    document.getElementById('resetBtn').addEventListener('click', resetView);
    addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='r') resetView(); });
    document.getElementById('exportPNG').addEventListener('click', (e)=>{ e.preventDefault(); const url = renderer.domElement.toDataURL('image/png'); const a = document.createElement('a'); a.href = url; a.download = 'atom.png'; a.click(); });
  </script>
</body>
</html>
