<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Átomo — demo sólida</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1020;color:#e5e7eb;font-family:system-ui,Segoe UI,Inter,Arial}
    #app{position:fixed;inset:0}
    canvas{display:block;width:100%;height:100%}
    .tip{position:fixed;right:12px;top:12px;font-size:12px;opacity:.8;background:rgba(17,24,39,.55);border:1px solid #263247;padding:8px 10px;border-radius:10px}
    .fab{position:fixed;right:12px;bottom:12px;border:1px solid #263247;background:#18223a;color:#e5e7eb;border-radius:999px;padding:8px 12px;cursor:pointer}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="tip">Arrastra para girar · Rueda para zoom · R para reset</div>
  <button class="fab" id="resetBtn">Recentrar</button>

  <!-- THREE r149 (última estable con <script src>) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
  <script>
  (function(){
    // --- Setup básico ---
    const root = document.getElementById('app') || document.body;
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    root.appendChild(renderer.domElement);

    const scene  = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 2000);
    let camDist = 14;  // distancia inicial
    camera.position.set(8, 6, camDist);
    camera.lookAt(0,0,0);

    // Luces sencillas (Phong es muy tolerante)
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(5,7,3);
    scene.add(dir);

    // --- Grupo raíz del átomo (lo giramos con el ratón) ---
    const atom = new THREE.Group();
    scene.add(atom);

    // Núcleo
    const nucleus = new THREE.Mesh(
      new THREE.SphereGeometry(1.2, 32, 32),
      new THREE.MeshPhongMaterial({ color: 0x8893ff, shininess: 60, emissive: 0x1a1f5a, emissiveIntensity: 0.35 })
    );
    atom.add(nucleus);

    // Pequeño glow
    const glow = new THREE.PointLight(0x7dd3fc, 0.6, 40);
    atom.add(glow);

    // --- Órbitas y electrones usando pivotes (sólido y simple) ---
    const RINGS = 3;
    const GAP   = 1.2;
    const BASE  = 2.3;
    const electrons = []; // {pivot, sphere, speed}

    function addRing(radius, electronsCount){
      // Un torus finito como órbita
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(radius, Math.max(0.015*radius, 0.03), 12, 180),
        new THREE.MeshBasicMaterial({ color: 0x8b5cf6, wireframe:true, transparent:true, opacity:0.35 })
      );

      // Pivot independiente por anillo (lo rotamos para orbitar)
      const pivot = new THREE.Object3D();

      // Orientación aleatoria del plano del anillo
      pivot.rotation.x = Math.random()*Math.PI;
      pivot.rotation.y = Math.random()*Math.PI;

      pivot.add(ring);
      atom.add(pivot);

      // Electrones de este anillo
      for(let i=0;i<electronsCount;i++){
        const e = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 24, 24),
          new THREE.MeshPhongMaterial({ color: 0x22d3ee, emissive: 0x0ea5e9, emissiveIntensity: 0.8 })
        );
        // Posición inicial sobre +X del anillo y desfase angular para repartirlos
        const holder = new THREE.Object3D();
        holder.position.x = radius;
        const phase = (i/electronsCount)*Math.PI*2;
        holder.rotation.y = phase;
        pivot.add(holder);
        holder.add(e);

        electrons.push({
          pivot, holder, sphere:e,
          speed: (0.4 + Math.random()*0.6) * 0.8  // rad/s
        });
      }

      return pivot;
    }

    // Construcción del átomo
    const electronsPerRing = [2, 8, 8]; // editable
    for(let i=0;i<RINGS;i++){
      const radius = BASE + i*GAP;
      addRing(radius, electronsPerRing[i] || 0);
    }

    // --- Controles de ratón (rotación grupo) + zoom rueda ---
    let isDown=false, lastX=0, lastY=0;
    renderer.domElement.addEventListener('mousedown', e => { isDown=true; lastX=e.clientX; lastY=e.clientY; });
    window.addEventListener('mouseup',   ()=> { isDown=false; });
    window.addEventListener('mousemove', e => {
      if(!isDown) return;
      const dx = e.clientX-lastX, dy = e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
      atom.rotation.y += dx*0.005;
      atom.rotation.x += dy*0.005;
    }, {passive:true});
    renderer.domElement.addEventListener('wheel', e => {
      e.preventDefault();
      camDist *= (1 + Math.sign(e.deltaY)*0.08);
      camDist = Math.max(4, Math.min(40, camDist));
      // Actualiza cámara manteniendo dirección hacia el origen
      const dirVec = new THREE.Vector3().subVectors(camera.position, new THREE.Vector3(0,0,0)).normalize();
      camera.position.copy(dirVec.multiplyScalar(camDist));
      camera.lookAt(0,0,0);
    }, {passive:false});

    // Reset
    function resetView(){
      atom.rotation.set(0,0,0);
      camDist = 14;
      camera.position.set(8,6,camDist);
      camera.lookAt(0,0,0);
    }
    document.getElementById('resetBtn').addEventListener('click', resetView);
    window.addEventListener('keydown', e => { if(e.key.toLowerCase()==='r') resetView(); });

    // --- Animación ---
    const clock = new THREE.Clock();
    function animate(){
      const dt = clock.getDelta();

      // Giro lento del núcleo y parpadeo de luz
      nucleus.rotation.y += dt*0.25;
      nucleus.rotation.x += dt*0.12;
      glow.intensity = 0.45 + 0.15*Math.sin(performance.now()*0.0015);

      // Orbitar electrones (giramos el holder sobre su pivot)
      for(const e of electrons){
        e.holder.rotation.y += e.speed * dt;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

  })();
  </script>
</body>
</html>
